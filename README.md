# Дизайн-документ
## Реализовано
- синхронная валидация одного поля (пример - минимальная длина поля)
- асинхронная валидация одного поля (пример - проверка на сервере занято ли имя пользователя)
## Реализация
Форма состоит из `FormControl`. Каждый `FormControl` может быть в одном из пяти состояний:
- `pristine` - начальное состояние
- `editing` - состояние редактирования
- `valid` - значение валидно
- `invalid` - значение невалидно. Дочерние состояния генерируются автоматически.
- `validating` - запущены асинхронные валидаторы

Внешнее API генератора выглядит так:
```javascript
{
  controls: {
    email: { // Имя FormControl
      value: '', // Значение по умолчанию
      validators: { // Валидаторы
        sync: [ // Синхронные валидаторы
          {
            name: 'empty', // Имя, идентифицирующее ошибку
            message: 'Email is required', // Сообщение об ошибке
            validate: Validator.required() // Функция-валидатор. Можно использовать встроенные.
          },
          { name: 'incorrectEmail', message: 'Email must be a valid email address', validate: Validator.email() },
        ],
        async: [ // Асинхронные валидаторы
          {
            name: 'used', // Имя, идентифицирующее ошибку
            validate: (val) => api.checkEmailUsage(val) // Функция, которая должна возвращать Promise, который резолвится с объектом { valid: true, message: string }, где valid - результат валидации, message - сообщение об ошибке.
          },
          { name: 'bannedDomain', validate: (val) => api.checkDomainBanStatus(val) },
        ],
      },
    },
    password: {
      value: '',
      validators: {
        sync: [
          { name: 'empty', message: 'Password is required', validate: Validator.required() },
          { name: 'minLength', message: 'Password must be at least 4 characters long', validate: Validator.min(4) },
        ],
      },
    },
  },
}
```
## Альтернативные варианты реализации.
Были рассмотрены варианты реализации:
- Без специальных состояний для каждой ошибки. Эти состояния неявно присутствуют в контексте. Этот вариант часто предлагается в статьях, посвящённых описанию форм на `XState`. Он привлекателен простотой реализации - количество состояний, описанных явно, очень мало. Ментально проще работать с такой машиной, но строгость описания страдает.

- Во внешнем API нет разделения на асинхронные и синхронные валидаторы. Чтобы сделать валидатор асинхронным, достаточно передать вместо обычной функции асинхронную. После чего происходила `instanceof` проверка в коде.
```javascript
const AsyncFunction = (async () => {}).constructor;
const fnType = validator instanceof AsyncFunction ? 'async' : 'sync';
```
Проблема заключается в том, что во время транспиляции в старые, но все ещё актуальные, стандарты языка (например, `ES5`) асинхронная функция преобразуется в синхронную. После этого было решено всё же явно разделять типы валидаторов.