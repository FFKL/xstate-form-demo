# Дизайн-документ
## Как запустить?
Скрипт установит все зависимости и запустит сервер для демонстрации.
```bash
./run.sh
```
## Как потыкать демку?
### E-mail
Для синхронной валидации адреса почты необходимо ввести строку, в которой присутствует `@`. Для прохождения асинхронной валидации поле должно включать домен `javascript.samurai` и не являться зарезервированными имейлами - `samurai@javascript.samurai` либо `ninja@javascript.samurai`.
### Пароль
Пароль должен состоять хотя бы из 4 символов.
### Submit
С почтой `valid@javascript.samurai` форма успешно сабмитится. При любой другой - сабмит проваливается.
## Реализовано
- синхронная валидация одного поля (пример - минимальная длина поля)
- асинхронная валидация одного поля (пример - проверка на сервере занято ли имя пользователя)
## Реализация
Форма состоит из `FormControl`. Каждый `FormControl` может быть в одном из пяти состояний:
- `pristine` - начальное состояние
- `editing` - состояние редактирования
- `valid` - значение валидно
- `invalid` - значение невалидно. Дочерние состояния генерируются автоматически.
- `validating` - запущены асинхронные валидаторы

Внешнее API генератора выглядит так:
```javascript
{
  controls: {
    email: { // Имя FormControl
      value: '', // Значение по умолчанию
      validators: { // Валидаторы
        sync: [ // Синхронные валидаторы
          {
            name: 'empty', // Имя, идентифицирующее ошибку
            message: 'Email is required', // Сообщение об ошибке
            validate: Validator.required() // Функция-валидатор. Можно использовать встроенные.
          },
          { name: 'incorrectEmail', message: 'Email must be a valid email address', validate: Validator.email() },
        ],
        async: [ // Асинхронные валидаторы
          {
            name: 'used', // Имя, идентифицирующее ошибку
            validate: (val) => api.checkEmailUsage(val) // Функция, которая должна возвращать Promise, который резолвится с объектом { valid: true, message: string }, где valid - результат валидации, message - сообщение об ошибке.
          },
          { name: 'bannedDomain', validate: (val) => api.checkDomainBanStatus(val) },
        ],
      },
    },
    password: {
      value: '',
      validators: {
        sync: [
          { name: 'empty', message: 'Password is required', validate: Validator.required() },
          { name: 'minLength', message: 'Password must be at least 4 characters long', validate: Validator.min(4) },
        ],
      },
    },
  },
}
```
### Недостатки
- Нельзя изменить контракт возврата асинхронного результата. Он фиксированный. Нужно адаптировать под каждый вызов.
- Использование `"In State" Guards` для сабмита формы. В документации предостерегают от использования таких гардов, но! я так и не понял, почему это не очень хорошо и как этого избежать. Хочется прояснить этот момент при обсуждении.
- Хотелось бы более похожих контрактов для синхронных и асинхронных валидаторов - описано в секции `Альтернативные варианты реализации`.
- Необходимость следить за корректным сбрасыванием ошибок/значений формы при генерации стейт-машины.

### Почему выбрано API
Выбранное API не завязано на конкретный вариант ввода - можно использовать `textarea`, `input`, любой кастомный `control`. Предусмотрена возможность для расширения объекта валидацией формы - описание контролов вынесено в свойство `controls`. Асинхронные и синхронные валидаторы разделены, поскольку их обработка различна.

## Альтернативные варианты реализации.
Были рассмотрены варианты реализации:
- Без специальных состояний для каждой ошибки. Эти состояния неявно присутствуют в контексте. Этот вариант часто предлагается в статьях, посвящённых описанию форм на `XState`. Он привлекателен простотой реализации - количество состояний, описанных явно, очень мало. Ментально проще работать с такой машиной, но строгость описания страдает.

- Во внешнем API нет разделения на асинхронные и синхронные валидаторы. Чтобы сделать валидатор асинхронным, достаточно передать вместо обычной функции асинхронную. После чего происходила `instanceof` проверка в коде.
```javascript
const AsyncFunction = (async () => {}).constructor;
const fnType = validator instanceof AsyncFunction ? 'async' : 'sync';
```
Проблема заключается в том, что во время транспиляции в старые, но все ещё актуальные, стандарты языка (например, `ES5`) асинхронная функция преобразуется в синхронную. После этого было решено всё же явно разделять типы валидаторов.